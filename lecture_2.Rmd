---
title: "Lecture 2 - Simple neuron models"
author: "Author: Matthew J. Cossley"
date: "Last update: `r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_float:
        collapsed: false
        smooth_scroll: true
    toc_depth: 3
    fig_caption: yes
    # code_folding: show
    number_sections: false
    theme: cosmo
fontsize: 14pt
---

```{r setup, include=FALSE}
library(reticulate)
use_python('/Users/mq20185996/miniconda3/bin/python')
```

## Leaky integrate and fire

$$
\frac{d}{dt} v(t) = b - v(t) \\
\text{if } v(t) = 1, \text{then } v(t) \leftarrow 0
$$

```{python}
import numpy as np
import matplotlib.pyplot as plt

T = 100
tau = 0.01
t = np.arange(0, T, tau)
n = t.shape[0]

v = np.zeros(n)

b = np.concatenate(([0.0] * (t.shape[0] // 3),
                    [1.001] * (t.shape[0] // 3),
                    [0.0] * (t.shape[0] // 3)))
                    
for i in range(1, n):
  
  dvdt = b[i-1] - v[i-1]
  dt = t[i] - t[i-1]
  
  v[i] = v[i-1] + dvdt * dt
  
  if v[i] > 1:
    v[i] = 0
    
fig, ax, = plt.subplots(1, 1, squeeze=False)
ax[0, 0].plot(t, v)
ax[0, 0].set_ylabel('v')
ax[0, 0].set_xlabel('t')
plt.show()
```


## Quadratic integrate and fire

$$
\frac{d}{dt} v(t) = b + v^2(t) \\
\text{if } v(t) = v_{\text{peak}},
\text{then } v(t) \leftarrow v_{\text{reset}}
$$

```{python}
import numpy as np
import matplotlib.pyplot as plt

step = 0.1 # integration time step
T = 90 # total ms of the simulation
t = np.arange(0, T, step) # initialise time array

v = np.zeros(t.shape) # initialise potential with zeros
vreset = 0 # define initial membrane potential
vpeak = 1 # define the firing threshold
v[0] = vreset # set initial membrane potential

b = np.concatenate(([0.0] * (t.shape[0] // 3),
                    [0.02] * (t.shape[0] // 3),
                    [0.0] * (t.shape[0] // 3)))

for i in range(1, t.shape[0]):
  
  dvdt = b[i-1] + v[i-1]**2
  dt = t[i] - t[i-1]
  
  v[i] = v[i-1] + dvdt * dt
  
  if v[i] > vpeak:
    v[i] = vreset

fig, ax, = plt.subplots(1, 1, squeeze=False)
ax[0, 0].plot(t, v)
ax[0, 0].set_ylabel('v')
ax[0, 0].set_xlabel('t')
plt.show()
```

## Izhikevich Neuron

$$
\begin{align}
C \frac{d}{dt} v(t) &= -k(v(t) - v_r) (v(t) - v_t) - u(t) + I(t) \\
\frac{d}{dt} u(t) &= a \big(b(v(t) - v_r) - u(t)\big) \\
\text{ if} &\quad v(t) > v_{\text{peak}} \\
\text{ then} &\quad v(t) \leftarrow c, \quad u(t) \leftarrow u(t) + d
\end{align}
$$

### Regular Spiking
```{python}
import numpy as np
import matplotlib.pyplot as plt

T = 1000
tau = 1
t = np.arange(0, T, tau)
n = t.shape[0]

C = 100
vr = -60
vt = -40
vpeak = 35

a = 0.03
b = -2
c = -50
d = 100
k = 0.7

u = np.zeros(t.shape)
v = np.zeros(t.shape)
v[0] = vr

I = np.zeros(n)
I[n//10:] = 70

for i in range(1, n):
  
  dvdt = (k * (v[i-1] - vr) * (v[i-1] - vt) - u[i-1] + I[i-1]) / C
  dudt = a * (b * (v[i-1] - vr) - u[i-1])
  dt = t[i] - t[i-1]
  
  v[i] = v[i-1] + dvdt * dt
  u[i] = u[i-1] + dudt * dt
  
  if v[i] > vpeak:
    v[i-1] = vpeak
    v[i] = c
    u[i] = u[i] + d

fig, ax, = plt.subplots(1, 1, squeeze=False)
ax[0, 0].plot(t, v)
ax[0, 0].set_ylabel('v')
ax[0, 0].set_xlabel('t')
plt.show()
```


### Bursting

```{python}
import numpy as np
import matplotlib.pyplot as plt

T = 1000
tau = 1
t = np.arange(0, T, tau)
n = t.shape[0]

C = 100
vr = -75
vt = -45
vpeak = 50

a = 0.01
b = 5
c = -56
d = 130
k = 1.2

u = np.zeros(t.shape)
v = np.zeros(t.shape)
v[0] = vr

I = np.zeros(n)
I[n//10:] = 550

for i in range(1, n):
  
  dvdt = (k * (v[i-1] - vr) * (v[i-1] - vt) - u[i-1] + I[i-1]) / C
  dudt = a * (b * (v[i-1] - vr) - u[i-1])
  dt = t[i] - t[i-1]
  
  v[i] = v[i-1] + dvdt * dt
  u[i] = u[i-1] + dudt * dt
  
  if v[i] > vpeak:
    v[i-1] = vpeak
    v[i] = c
    u[i] = u[i] + d

fig, ax, = plt.subplots(1, 1, squeeze=False)
ax[0, 0].plot(t, v)
ax[0, 0].set_ylabel('v')
ax[0, 0].set_xlabel('t')
plt.show()
```


### Chattering

```{python}
import numpy as np
import matplotlib.pyplot as plt

T = 1000
tau = 1
t = np.arange(0, T, tau)
n = t.shape[0]

C = 50
vr = -60
vt = -40
vpeak = 25

a = 0.03
b = 1
c = -40
d = 150
k = 1.5

u = np.zeros(t.shape)
v = np.zeros(t.shape)
v[0] = vr

I = np.zeros(n)
I[n//10:] = 300

for i in range(1, n):
  
  dvdt = (k * (v[i-1] - vr) * (v[i-1] - vt) - u[i-1] + I[i-1]) / C
  dudt = a * (b * (v[i-1] - vr) - u[i-1])
  dt = t[i] - t[i-1]
  
  v[i] = v[i-1] + dvdt * dt
  u[i] = u[i-1] + dudt * dt
  
  if v[i] > vpeak:
    v[i-1] = vpeak
    v[i] = c
    u[i] = u[i] + d

fig, ax, = plt.subplots(1, 1, squeeze=False)
ax[0, 0].plot(t, v)
ax[0, 0].set_ylabel('v')
ax[0, 0].set_xlabel('t')
plt.show()
```