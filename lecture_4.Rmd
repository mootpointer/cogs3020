---
title: "Lecture 4 - Neurotransmitter release"
author: "Author: Matthew J. Cossley"
date: "Last update: `r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_float:
        collapsed: true
        smooth_scroll: true
    toc_depth: 3
    fig_caption: yes
    # code_folding: show
    number_sections: false
    theme: cosmo
fontsize: 14pt
---

```{r setup, include=FALSE}
library(reticulate)
use_python('/Users/mq20185996/miniconda3/bin/python')
```

## Synaptics responses

* Action potentials lead to neurotransmitter release which
float across the synaptic cleft and bind to postsynaptic
receptors on a receiving neuron, causing excitatory or
inhibitory postsynaptic potentials (EPSP or IPSP) in the
receiving neuron. The timecourse of the PSP on the receiving
membrane potential is commonly modelled as follows.

$$
\Delta V_{\text{PSP}}(t) =  A t e^{\frac{-t}{t_{\text{peak}}}}
$$

* $A$ is amplitude parameter

* $t_{\text{peak}}$ is the time at which $\Delta
V_{\text{PSP}}(t)$ reaches its max value.

* In neuroscience, this function is often called the *alpha function*.

```{python}
import numpy as np
import matplotlib.pyplot as plt

tau = 0.1
T = 10
A = 1
t_peak = 2
t = np.arange(0, T, tau)
n = t.shape[0]
v_psp= A * t * np.exp(-t/t_peak)

fig, ax = plt.subplots(1, 1, squeeze=False)
ax[0,0].plot(t, v_psp)
ax[0,0].set_xlabel('x')
ax[0,0].set_ylabel('V')
plt.show()
```

## Spikes as a change in conductance

* This PSP timecourse can also be obtained modelling the
effect of an action potential on the ion conductivity of a
receiving membrane potential as follows.

$$
\frac{d}{dt}g(t) = (-g(t) + A_{\text{psp}} \delta(t_{\text{spike}})) / t_{\text{psp}}
$$

* $g(t)$ is the conductance of the receiving membrane patch.

* $A_{\text{psp}}$ is an amplitude parameter that determines
how much each individual spike influences the conductance of
the receiving neuron.

* $t_{\text{psp}}$ is a time constant that determines how
quickly the influence of spike on conductance fades away.

* $t_{\text{spike}}$ is the time of the next spike and
$\delta()$ is a delta function -- it is one wherever $t =
t_{\text{spike}}$ and zero everwhere else.

```{python}
g = np.zeros(n)
spike = np.zeros(n)
spike[20] = 1

for i in range(n):
  dgdt = (-g[i-1] + A * spike[i-1]) / t_peak
  dt = t[i] - t[i-1]
  
  g[i] = g[i-1] + dgdt * dt

fig, ax = plt.subplots(1, 1, squeeze=False)
ax[0,0].plot(t, g)
ax[0,0].set_xlabel('x')
ax[0,0].set_ylabel('V')
plt.show()
```

* Notice that the assumed effect of the conductance is
climbs from zero to its full magnitude in one time step. I
don't think this is a particularly realistic model of the
timecourse of conductance changes, but as we see next, it
leads to PSPs that are realistic looking.

## Coupling conductance to PSP

* We couple the above model of conductance change to a
simple model of membrane potential with the following simple
differential equations.

$$
\frac{d}{dt}v(t) = (g(t) (v(t) - E) - g_{\text{leak}} v(t)) / C \\
\frac{d}{dt}g(t) = (-g(t) + A_{\text{psp}} \delta(t_{\text{spike}})) / t_{\text{psp}}
$$

```{python}
tau = 0.1
T = 20
A = 1
t_peak = 2
t = np.arange(0, T, tau)
n = t.shape[0]

v = np.zeros(n)
g = np.zeros(n)
spike = np.zeros(n)
spike[20] = 1
E = -1
g_leak = 1
C=1
for i in range(n):
  dvdt = (g[i-1]*(v[i-1]-E) - g_leak * v[i-1]) / C
  dgdt = (-g[i-1] + A * spike[i-1]) / t_peak
  dt = t[i] - t[i-1]
  
  v[i] = v[i-1] + dvdt * dt
  g[i] = g[i-1] + dgdt * dt

fig, ax = plt.subplots(2, 1, squeeze=False)
ax[0,0].plot(t, v)
ax[0,0].set_xlabel('t')
ax[0,0].set_ylabel('v')
ax[1,0].plot(t, g)
ax[1,0].set_xlabel('t')
ax[1,0].set_ylabel('g')
plt.show()
```

## PSPs superimpose

* You can play around with the spike train frequency and
number etc in the above to see how PSPs superimpose with
multiple spikes. E.g., see below.

```{python}
tau = 0.1
T = 100
A = 1
t_peak = 2
t = np.arange(0, T, tau)
n = t.shape[0]

v = np.zeros(n)
g = np.zeros(n)
spike = np.zeros(n)
spike[20::30] = 1
E = -10
g_leak = 1
C=1
for i in range(n):
  dvdt = (g[i-1]*(v[i-1]-E) - g_leak * v[i-1]) / C
  dgdt = (-g[i-1] + A * spike[i-1]) / t_peak
  dt = t[i] - t[i-1]
  
  v[i] = v[i-1] + dvdt * dt
  g[i] = g[i-1] + dgdt * dt

fig, ax = plt.subplots(2, 1, squeeze=False)
ax[0,0].plot(t, v)
ax[0,0].set_xlabel('t')
ax[0,0].set_ylabel('v')
ax[1,0].plot(t, g)
ax[1,0].set_xlabel('t')
ax[1,0].set_ylabel('g')
plt.show()
```

* Note that you are not seeing action potentials from the
above code. In fact, the above code doesn't even have a
mechanism to generate an action potential even if $v$ became
very depolarised. Rather, we are seeing PSPs. In practice,
enough spikes will cuase many superimposing PSPs and that
will cause the receiving cell to fire. We turn to that next.

## PSP model in the Izhikevich neuron

* We can also easily embed this sort of modelling of PSPs
into other neuron types. To build moderate to large
networks, we will end up relying on Izhikevich neurons, so
we look at that next.

* The differential equations for an Izhikevich neuron is
given by the following:

$$
\begin{align}
C \frac{d}{dt} v(t) &= k(v(t) - v_r) (v(t) - v_t) - u(t) + I(t) \\
\frac{d}{dt} u(t) &= a \big(b(v(t) - v_r) - u(t)\big) \\
\text{ if} &\quad v(t) > v_{\text{peak}} \\
\text{ then} &\quad v(t) \leftarrow c, \quad u(t) \leftarrow u(t) + d
\end{align}
$$

* Check back over previous lecture notes for a description
of what each parameter does.

* For me, trickiest part is thinking about where to place
$g(t)$. The form of the Izhikevich neuron looks different
enough from the leaky conductance model from above that it
isn't immediately obvious what we should do.

* Although my explanation here won't be completely
satisfactory, you can see that it works just like we want it
to when we substitute $g(t)$ in for the $I(t)$ term.

* I make sense of this by remembering that we use $I(t)$ to
model any external current input, and this is precisely what
a spike is from the perspective of the receiving cell.

```{python}
import numpy as np
import matplotlib.pyplot as plt

tau = 0.1
T = 100
t = np.arange(0, T, tau)
n = t.shape[0]

C = 50
vr = -80
vt = -25
vpeak = 40
k = 1
a = 0.01
b = -20
c = -55
d = 150

g = np.zeros(n)
spike = np.zeros(n)
# spike[200:800:10] = 100
spike[200] = 100
psp_amp = 100
psp_decay = 10

v = np.zeros(n)
u = np.zeros(n)
v[0] = vr

for i in range(1, n):

    dvdt = (k * (v[i - 1] - vr) * (v[i - 1] - vt) - u[i - 1] + g[i-1]) / C
    dudt = a * (b * (v[i - 1] - vr) - u[i - 1])
    dgdt = (-g[i - 1] + psp_amp * spike[i - 1]) / psp_decay
    dt = t[i] - t[i - 1]

    v[i] = v[i - 1] + dvdt * dt
    u[i] = u[i - 1] + dudt * dt
    g[i] = g[i - 1] + dgdt * dt

    if v[i] >= vpeak:
        v[i - 1] = vpeak
        v[i] = c
        u[i] = u[i] + d

fig, ax = plt.subplots(2, 1, squeeze=False)
ax[0, 0].plot(t, v)
ax[1, 0].plot(t, g)
plt.show()
```

